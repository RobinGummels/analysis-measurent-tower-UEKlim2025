---
title: "Auswertung Temperatur- und Feuchtigkeits-Daten 18.11.2025-09.12.2025"
author: "Robin Gummels, Humam Hikmat, Lenn Kruck"
format: 
  revealjs: 
    theme: dark
    self-contained: true
editor: visual
---

# Wir haben unsere Auswertung mit R gemacht

## Was ist R?
- Open-Source Programmiersprache speziell für Statistik und Datenanalyse
- Bringt tausende Pakete für Auswertung, Visualisierung und Reproduzierbarkeit mit
- Funktioniert interaktiv (Konsole/RStudio) und in Skripten für reproduzierbare Workflows
- Läuft auf allen gängigen Betriebssystemen und ist frei verfügbar

## Warum R?
- Saubere Trennung von Code, Daten und Ergebnis: Analysen bleiben nachvollziehbar
- Starke Visualisierung (z.B. `ggplot2`) für schnelle Diagramme unserer Messdaten
- Große Community und Dokumentation; Probleme sind meist schon gelöst
- Passt gut zu Quarto: Text, Code und Grafiken in einer präsentation kombinierbar

## Slide 2

When you click the **Render** button a document will be generated that includes:

-   Content authored with markdown
-   Output from executable code

## Slide 3 mit Code 1

When you click the **Render** button a presentation will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
#| echo: true
1 + 1
```

## Daten einlesen - Steinfurter Straße

Als erstes Laden wir die Daten von der Steinfurter Straße:
<details>
<summary>Code</summary>
```{r}
#| echo: true 
#| message: true

# Header aus erster Zeile auslesen
csv_headers = read.csv2(file = "data/data-as-csv/metMastSteinfurterStr.csv", 
                        header = FALSE, nrows = 1, as.is = TRUE)

# Daten ab Zeile 6 einlesen mit den Header-Namen
data <- read.csv2(
  "data/data-as-csv/metMastSteinfurterStr.csv",
  skip = 5,
  header = FALSE,
  dec = ","
)
colnames(data) <- csv_headers
```
</details>

```{css, echo=FALSE}
/* Schriftgröße VOR der DT-Berechnung setzen */
.dataTables_wrapper {
  font-size: 11px !important;
}
.dataTables_wrapper table thead th {
  font-size: 10px !important;
  padding: 3px 5px !important;
  max-width: 120px;
  overflow: hidden;
  text-overflow: ellipsis;
}
.dataTables_wrapper table tbody td {
  font-size: 11px !important;
  padding: 2px 4px !important;
}
```

```{r}
DT::datatable(
  data,
  options = list(
    scrollY = "350px",
    scrollX = TRUE,
    pageLength = 50,
    searching = FALSE,
    paging = FALSE,
    info = FALSE,
    autoWidth = FALSE,
    columnDefs = list(
      list(width = "90px", targets = 0),  # Zeitstempel etwas breiter
      list(width = "60px", targets = "_all")  # Alle anderen schmal
    ),
    initComplete = htmlwidgets::JS(
      "function(settings, json) {",
      "  this.api().columns.adjust();",
      "}"
    )
  ),
  class = "compact cell-border stripe",
  style = "bootstrap"
)
```

## Was ist Autokorrelation?

**Autokorrelation** misst, wie stark ein Messwert mit früheren Messwerten zusammenhängt.

- Wenn die Temperatur **jetzt** hoch ist, ist sie wahrscheinlich auch in 10 Minuten noch hoch
- Je weiter wir in die Vergangenheit schauen, desto schwächer wird dieser Zusammenhang
- **Hohe Autokorrelation** = starke Ähnlichkeit zwischen Werten mit bestimmtem Zeitabstand


## Was ist Autokorrelation?
**Mathematisch:**
$$
\text{ACF}(k) = \frac{\text{Kovarianz}(X_t, X_{t-k})}{\text{Varianz}(X_t)}
$$

wobei $k$ die Anzahl der Zeitschritte (Lag) zurück ist.

## Autokorrelation berechnen in R

```{r}
#| echo: true
#| eval: false
# acf() berechnet die Autokorrelation für verschiedene Lags
# lag.max = 432 entspricht 3 Tagen (432 × 10min = 4320min = 72h)
acf(data$`Durschnittl. Lufttemperatur [°C]`, lag.max = 432)
```

- **Lag 0**: Korrelation mit sich selbst (immer 1.0)
- **Lag 144**: Korrelation mit dem Wert von vor 24h (144 × 10min = 1440min = 24h)
- **Lag 288**: Korrelation mit dem Wert von vor 48h

Die blauen gestrichelten Linien zeigen die **Signifikanzgrenze** – Werte darüber sind statistisch bedeutsam.

## Autokorrelation der Temperatur

```{r}
#| echo: False
#| fig-width: 14
#| fig-height: 6

# ACF-Daten berechnen
temp_acf <- acf(data$`Durschnittl. Lufttemperatur [°C]`, 
                lag.max = 432, 
                plot = FALSE)

# Plot erstellen
plot(temp_acf, 
     main = "Autokorrelation der Lufttemperatur (10-Minuten-Daten)",
     xlab = "Lag (10-Minuten-Schritte)",
     ylab = "ACF",
     ci.col = "blue")

# 24h-Markierungen hinzufügen (alle 144 Lags = 24h)
abline(v = c(144, 288, 432), col = "red", lty = 2, lwd = 2)

# Beschriftung für die 24h-Marken
text(x = 144, y = 0.9, labels = "24h", col = "darkred", pos = 3, cex = 1.2, font = 2)
text(x = 288, y = 0.9, labels = "48h", col = "darkred", pos = 3, cex = 1.2, font = 2)
text(x = 432, y = 0.9, labels = "72h", col = "darkred", pos = 3, cex = 1.2, font = 2)
```

**Beobachtung:** Deutliche Spitzen alle 24 Stunden → Täglicher Temperaturzyklus!

## Interpretation: Tagesverlauf in den Daten

- **Hohe Autokorrelation bei Lag 144 (24h):** Die Temperatur jetzt ist stark korreliert mit der Temperatur zur gleichen Uhrzeit gestern
- **Wellenmuster:** Die Autokorrelation oszilliert mit einer Periode von ~144 Lags
- **Ursache:** Der tägliche Sonnenzyklus (Tag/Nacht) erzeugt eine periodische Temperaturschwankung

→ Um **langfristige Trends** zu erkennen, müssen wir diesen **Tagesverlauf herausrechnen**!

## Periodische Komponente (Tagesverlauf) rausrechnen
Um langfristigere Trends in der Temperatur besser zu erkennen, können die Temperaturschwankungen durch den Tagesverlauf herausrechnen:
```{r}

```